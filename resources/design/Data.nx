type Id = opaque String;

type MyUnion = Id or Int;

type Identified = struct {
  id: Id;
}

// Structs compose (statically)
type Foo = struct {
  count: Int,
  bytes: Array[Byte]
} + Identified;

type Password = opaque String;
type UserRow = struct {
  id: Long,
  name: String,
  password: Password
};

// oneof is easier to understand than enum, and more accurate for ADTs
type Animal = oneof {
  Dog = struct { breed: String },
  Cat = struct { isOrange: bool }
};
// Unlike in Rust, Animal.Dog is a proper type of its own.
val tucker = Dog { breed: "Brittany" };

type UserView = UserRow.type - ['password]

type Foo = struct {
  count: usize,
  bytes: u8[]
} + struct { id: Id };

val anon_struct = { x: 5, y: 10 };

val anon_type: Type = anon_struct.type;
// .type asks the compiler to generate type info
// This works since Type is an enum so there's a variant field to branch on at runtime
if (anon_type: Type.Struct) {
  // Narrowing rules let us treat anon_type as if it were declared as a Struct here
  // i.e., anon_type: Type.Struct
  anon_type.fields
}
val fooJsonWriter = impl JsonWriter[Foo] {
  fn write(value: Foo) = {
    mut buffer = JsonObject::empty();
    val fields = Foo.fields.map { f =>
      buffer.append(toJsType(f.type), toJsValue(value.getField(f));
    }
  }
}
val anonJsonWriter = impl JsonWriter[anon_type] {
  fn write(a: anon_type)
}
anon_type.fields.map(f => println(f.name));

