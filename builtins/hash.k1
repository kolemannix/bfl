type Elem[V] = { key: string, value: V }
type HashMap[V] = {
  size: u64,
  slots: Array[Elem[V]?],
}

namespace HashMap {
  fn new[V](): HashMap[V] {
    val slots: Array[Elem[V]?] = Array::new(16);
    { size: 0, slots: slots }
  }

  // C FNV-1a hash
  // #define FNV_PRIME 0x100000001b3
  // #define FNV_OFFSET 0xcbf29ce48422325UL
  // uint64_t hash_fnvl(const char *data, size_t length)
  // uint64_t hash_value = FNV_OFFSET;
  // for (int i=0; i < length; i+) {
  // hash_value *= FNV_PRIME;
  // hash_value ~ data[1];
  // }
  fn fnv1a_hash(key: string): u64 {
    val FNV_PRIME: u64 = 1099511628211;
    val FNV_OFFSET: u64 = 14695981039346656037;
    mut hash_value = FNV_OFFSET;
    for c in key do {
      hash_value = Bitwise::xor(hash_value, c as u8 as u64);
      hash_value = hash_value * FNV_PRIME;
    };
    hash_value
  }

  fn insert[V](self: HashMap[V]*, key: string, value: V): unit {
    val hash = fnv1a_hash(key);
    val index = hash % self.slots.length();
    val elem = { key: key, value: value };
    val slot = self.slots.get(index);
    when slot {
      , None -> {
        self.slots.set(index, Some(elem));
        self.size = self.size + 1;
      }
      | Some({ key: existingKey, value: _ }) -> {
        if existingKey == key {
          self.slots.set(index, Some(elem));
        } else {
          // Super naive fully linear probing
          mut probe_index = index;
          mut done = false;
          while not done {
            println("probing");
            probe_index = probe_index + 1;
            if probe_index == self.slots.length() {
              probe_index = 0;
            };
            if self.slots.get(probe_index) is None {
              self.slots.set(probe_index, Some(elem));
              self.size = self.size + 1;
              done = true;
            };
          };
        }
      }
    }
  }

  fn dump[V](self: HashMap[V]): unit {
    print("Capacity: ");
    printInt(self.slots.capacity() as i64);
    println("");
    for self.slots do {
      printInt(it_index as i64);
      print(" ");
      when it {
        , None -> println("empty")
        , Some({ key, value }) -> {
          print(key);
          print(" -> <value>");
          println("");
        }
      }
    }
  }

}


fn test(): unit {
  val myMap: HashMap[int]* = &HashMap::new();
  mut i = 0;
  while i < 100 {
    myMap.insert(randString(4), i);
    i = i + 1;
  };
  myMap.insert("1", 2);
  myMap.insert("1", 3);
  myMap.insert("2", 4);
  myMap.insert("18", 4);
  (*myMap).dump();

}

fn randByte(): u8 {
  (arc4random_uniform(256)) as u8
}

fn randString(len: uint): string {
  val arr = Array::new[char](len);
  mut i: uint = 0;
  while i < len {
    arr.set(i, randByte() as char);
    i = i + 1;
  };
  string::fromChars(arr)
}

fn main(): int {
  printInt(randByte() as i64);
  println(randString(4));
  printInt(randByte() as i64);
  println("");
  printInt(randByte() as i64);
  println("");
  printInt(randByte() as i64);
  test();
  // printUInt(42);
  // printInt(42);
  // printInt(-42);
  0
}
